// main.rs 
use std::process::Command;
use std::time::{Instant, Duration};
use std::default::Default;
use std::fs::File;
use std::io::{BufWriter, Write};
use mpi::topology::Communicator;
use mpi::collective::CommunicatorCollectives;

use ndarray::Array1;

use noci_rs::input::Input;
use noci_rs::AoData;
use noci_rs::SCFState;

use noci_rs::input::load_input;
use noci_rs::read::read_integrals;
use noci_rs::basis::{generate_reference_noci_basis, generate_qmc_noci_basis};
use noci_rs::noci::{calculate_noci_energy, build_noci_matrices};
use noci_rs::deterministic::{propagate, projected_energy};
use noci_rs::stochastic::{step};
use noci_rs::utils::{wavefunction_sparsity};
use noci_rs::mpiutils::{broadcast};

// Timing storage for various segements of code.
#[derive(Default, Clone, Copy)]
struct Timings {
    pyscf: Duration,
    scf: Duration,
    noci_ref_total: Duration,
    noci_ref_h: Duration,
    // Deterministic timings.
    qmc_det_total: Duration,
    qmc_det_basis: Duration,
    qmc_det_h: Duration,
    qmc_det_prop: Duration,
    // Stochastic timings. No timing for forming Hamiltonian as we do not do this in true QMC.
    qmc_stoch_total: Duration,
    qmc_stoch_basis: Duration,
    qmc_stoch_prop: Duration,
}

// Printed results for a given geometry.
struct Results {
    r: f64,
    states: Vec<SCFState>,
    e_rhf: f64,
    e_noci_ref: f64,
    e_noci_qmc_det: Option<f64>,
    e_noci_qmc_stoch: Option<f64>,
    e_fci: Option<f64>,
    timings: Timings,
}

type Atoms = Vec<String>;

/// Main.
fn main() {
    let t_total = Instant::now();
    let input_path = match std::env::args().nth(1) {
        Some(p) => p,
        None => {
            eprintln!("Usage: cargo run <input.lua>");
            std::process::exit(1);
        }
    };
    let mut input = load_input(&input_path);

    let mut prev_states: Vec<SCFState> = Vec::new();
    
    let universe = mpi::initialize().unwrap();
    let world = universe.world(); 
    let irank = world.rank();

    let rlist = input.mol.r_list.clone();
    let geoms = input.mol.geoms.clone();

    for (i, r) in rlist.iter().copied().enumerate() {
        println!("\n");
        let atoms: &Atoms = &geoms[i];
        let res = run(r, atoms, &mut input, &prev_states, &world);  
        if irank == 0 {print_report(&res, &input);}
        prev_states = res.states.clone();
    }
    if irank == 0 {println!("\n Total wall time: {:?}", t_total.elapsed());}
}

/// Wrapper fuction to call each required or requested type of calculation. Ordering is: 1)
/// Generate integrals in PySCF, run SCF for requested states, run the reference NOCI calculation,
/// and finally run the deterministic propagation NOCI-QMC calculation.
/// # Arguments:
///     `r`: f64, current geometry.
///     `atoms`: Vec<String>, atom types.
///     `prev_states`: [SCFState], converged SCF states at previous r, used for seeding.
fn run(r: f64, atoms: &Atoms, input: &mut Input, prev_states: &[SCFState], world: &impl Communicator) -> Results {

    let irank = world.rank();
    let mut timings = Timings::default();
    
    // Initialise timings struct and call PySCF.
    if irank == 0 {timings.pyscf = run_pyscf(atoms, input);}
    world.barrier();
    
    // Read in data generated by PySCF on all ranks.
    let ao: AoData = read_integrals("data.h5");

    // Create the following on all ranks such that they may be filled by broadcast.
    let mut states: Vec<SCFState> = Vec::new();
    let mut noci_reference_basis: Vec<SCFState> = Vec::new();
    let mut c0: Vec<f64> = Vec::new();
    let mut e_noci_ref: f64 = 0.0;
    let mut e_noci_qmc_det: Option<f64> = None;
    let mut e_noci_qmc_stoch: Option<f64> = None;
    
    // Run all non MPI parts of the code on rank 0. The deterministic propagation still uses Rayon
    // for multithreading. SCF calculations are currently single threaded. 
    if irank == 0 {
        // Run SCF calculations.
        let (st, d_scf) = run_scf(&ao, input, prev_states);
        states = st;
        timings.scf = d_scf;
        
        // Run NOCI reference calculation.
        let (refb, e_ref, c0v, d_tot, d_h_ref) = run_reference_noci(&ao, &states);
        // Note that noci_reference_basis and states above are the same if every requested basis
        // state in the input file has noci = true.
        noci_reference_basis = refb;
        e_noci_ref = e_ref;
        c0 = c0v;
        timings.noci_ref_total = d_tot;
        timings.noci_ref_h = d_h_ref;
        
        // Run deterministic NOCI-QMC calculation.
        if input.det.is_some() {
            let (e_det, d_tot, d_basis, d_h, d_prop) = run_qmc_deterministic_noci(&ao, input, &states, &noci_reference_basis, &c0);
            e_noci_qmc_det = Some(e_det);
            timings.qmc_det_total = d_tot;
            timings.qmc_det_basis = d_basis;
            timings.qmc_det_h = d_h;
            timings.qmc_det_prop = d_prop;
        }
    }

    world.barrier();
    broadcast(world, &mut states);
    broadcast(world, &mut noci_reference_basis);
    broadcast(world, &mut c0);
    broadcast(world, &mut e_noci_ref);

    // Run stochastic NOCI-QMC calculation
    if input.qmc.is_some() {
        let (e_qmc, d_qmc_stoch_total, d_qmc_stoch_basis, d_qmc_stoch_prop) = run_qmc_stochastic_noci(&ao, input, &noci_reference_basis, &c0, world);
        e_noci_qmc_stoch = Some(e_qmc);
        timings.qmc_stoch_total = d_qmc_stoch_total;
        timings.qmc_stoch_basis = d_qmc_stoch_basis;
        timings.qmc_stoch_prop = d_qmc_stoch_prop;
    }
    Results {r, e_rhf: states[0].e, e_noci_ref, e_noci_qmc_det, e_noci_qmc_stoch, e_fci: ao.e_fci, timings, states: states.clone()}
}

/// Call PySCF script to get the two electron integrals and core hamiltonian.
/// # Arguments: 
///     `atoms`: Vec<String>, atom types.
///     `input`: Input, user input specifications.
fn run_pyscf(atoms: &Atoms, input: &Input) -> Duration {
    let t_gen = Instant::now();
    let atomsj = serde_json::to_string(atoms).unwrap();
    
    // Call PySCF script via command line.
    let status = Command::new("python3").arg("generate.py").arg("--atoms").arg(&atomsj).arg("--basis").arg(&input.mol.basis)
                                        .arg("--unit").arg(&input.mol.unit).arg("--out").arg("data.h5").arg("--fci")
                                        .arg(if input.scf.do_fci { "true" } else { "false" }).status().unwrap();

    if !status.success() {
        eprintln!("Failed to generate mol with status {status}");
        std::process::exit(1);
    }

    t_gen.elapsed()
}

/// Run SCF calculations for user requested SCF states.
/// # Arguments:
///     `ao`: AoData, contains AO integrals and other system data.
///     `input`: Input, user input specifications.
///     `prev_states`: [SCFState], converged SCF states at previous r, used for seeding. 
fn run_scf(ao: &AoData, input: &Input, prev_states: &[SCFState]) -> (Vec<SCFState>, Duration) {
    let t_scf = Instant::now();
    
    // Use the previous states to seed new SCF calculations if they exist.
    let states = if prev_states.is_empty() {
        generate_reference_noci_basis(ao, input, None)
    } else {
        generate_reference_noci_basis(ao, input, Some(prev_states))
    };

    (states, t_scf.elapsed())
}

/// Construct the reference NOCI basis and find the reference NOCI energy via calculation of NOCI
/// Hamiltonian and overlap followed by solving GEVP.
/// # Arguments:
///     `ao`: AoData, contains AO integrals and other system data.
///     `states`: [SCFState], converged SCF states. 
fn run_reference_noci(ao: &AoData, states: &[SCFState]) -> (Vec<SCFState>, f64, Vec<f64>, Duration, Duration) {
    let t_noci = Instant::now();
    
    // Filter for the SCF states the user requested to be used in the NOCI basis.
    let noci_reference_basis: Vec<SCFState> = states.iter().filter(|s| s.noci_basis).cloned().collect();
    // Call matrix element and diagonalisation routines.
    let (e_noci_ref, c0, d_h_ref) = calculate_noci_energy(ao, &noci_reference_basis);

    (noci_reference_basis, e_noci_ref, c0.to_vec(), t_noci.elapsed(), d_h_ref)
}

/// Perform the deterministic propagation in the NOCI-QMC space. 
/// # Arguments:
///     `ao`: AoData, contains AO integrals and other system data.
///     `input`: Input, user input specifications.
///     `states`: [SCFState], converged SCF states. 
///     `noci_reference_basis`: [SCFState], the converged SCF states filtered for those requested
///                             to be in the NOCI basis.
///     `c0`: [f64], initial coefficient vector of basis states.
fn run_qmc_deterministic_noci(ao: &AoData, input: &Input, states: &[SCFState], noci_reference_basis: &[SCFState], c0: &[f64]) 
                             -> (f64, Duration, Duration, Duration, Duration) {
    let t_total = Instant::now();

    println!("{}", "=".repeat(100));
    println!("Building NOCI-QMC basis....");
    
    // Build excitations atop NOCI-reference basis.
    let t_basis = Instant::now();
    let basis = generate_qmc_noci_basis(ao, noci_reference_basis, input);
    let d_basis = t_basis.elapsed();

    let n = basis.len();
    println!("Built NOCI-QMC basis of {} determinants.", n);
    println!("Calculating NOCI-QMC deterministic propagation matrix elements for {} determinants ({} elements)...", n, n * n);
    println!("Progress will be printed every 5 minutes...");
    
    // Call matrix element routines.
    let (h, s, d_h) = build_noci_matrices(ao, &basis);
    println!("Finished calculating NOCI-QMC matrix elements.");
    
    // Choose initial shift.
    let es = states[0].e; // RHF energy.
    println!("Running deterministic NOCI-QMC propagation....");

    // Embed reference NOCI coefficient vector in full NOCI-QMC space.
    let mut c0qmc = Array1::<f64>::zeros(n); 
    // If we are not interested in plotting evolution of individual coefficients we use the
    // reference NOCI coefficients as our initial guess as this is the best guess, however,
    // the coefficients often don't change much which makes for a boring plot.
    if !input.write.write_deterministic_coeffs {
        for (i, ref_st) in noci_reference_basis.iter().enumerate() {
            let idx = basis.iter().position(|qmc_st| qmc_st.label == ref_st.label).unwrap();
            c0qmc[idx] = c0[i];
        }
    // If we are interested in plotting the evolution of individual coefficients we use an
    // equal weighting of all SCF states as our initial guess.
    } else {
        c0qmc = Array1::from_elem(n, 1.0 / (n as f64).sqrt());
    }; 

    println!("Initial wavefunction ansatz (C0-QMC): {}", c0qmc);
    
    // Save indices in the coefficients vector of the references.
    let ref_indices: Vec<usize> = noci_reference_basis.iter().map(|ref_st| {basis.iter()
                                  .position(|qmc_st| qmc_st.label == ref_st.label).unwrap()}).collect();
    
    // Coefficient storage if we are writing.
    let mut coefficients = Vec::new();
    
    // Perform the propagation.
    let t_prop = Instant::now();
    let c = propagate(&h, &s, &c0qmc, es, &mut coefficients, input);
    let d_prop = t_prop.elapsed();

    let cfinal = match c {
        Some(c) => c,
        None => {
            println!("Propagation failed."); 
            std::process::exit(1);
        }
    };
    
    // Calculate energy and final diagnostics.
    let e = projected_energy(&h, &s, &cfinal);
    wavefunction_sparsity(cfinal.as_slice().unwrap(), &ref_indices);
    
    // Write projected coefficients to a file. This should currently only be used if doing a single 
    // geometry at a time otherwise the previous file will be overwritten.
    if input.write.write_deterministic_coeffs {
        println!("Writing coefficients to file...");
        let filepath = format!("{}/{}", input.write.write_dir, "coefficients");
        let file = File::create(filepath).unwrap();
        let mut writer = BufWriter::new(file);
        for iter in &coefficients {
            writeln!(writer, "iter {}", iter.iter).unwrap();
            writeln!(writer, "Full coefficients:").unwrap();
            for (i, z) in iter.c_full.iter().enumerate() {
                writeln!(writer, "{:4} {:.8e}", i, z).unwrap();
            }
            writeln!(writer, "Relevant space coefficients:").unwrap();
            for (i, z) in iter.c_relevant.iter().enumerate() {
                writeln!(writer, "{:4} {:.8e}", i, z).unwrap();
            }
            writeln!(writer, "Null space coefficients:").unwrap();
            for (i, z) in iter.c_null.iter().enumerate() {
                writeln!(writer, "{:4} {:.8e}", i, z).unwrap();
            }
            writeln!(writer).unwrap(); 
        }
    }

    let d_total = t_total.elapsed();

    (e, d_total, d_basis, d_h, d_prop)
}

/// Perform stochastic propagation in the NOCI-QMC space. 
/// # Arguments:
///     `ao`: AoData, contains AO integrals and other system data.
///     `input`: Input, user input specifications.
///     `states`: [SCFState], converged SCF states. 
///     `noci_reference_basis`: [SCFState], the converged SCF states filtered for those requested
///                             to be in the NOCI basis.
///     `c0`: [f64], initial coefficient vector of basis states.
///     `world`: Communicator, MPI communicator object (MPI_COMM_WORLD).
pub fn run_qmc_stochastic_noci(ao: &AoData, input: &mut Input, noci_reference_basis: &[SCFState], c0: &[f64], world: &impl Communicator) 
                               -> (f64, Duration, Duration, Duration) {

    let t_total = Instant::now();
    let irank = world.rank();

    if irank == 0 {
        println!("{}", "=".repeat(100));
        println!("Building NOCI-QMC basis....");
    }
    
    // Build excitations atop NOCI-reference basis.
    let t_basis = Instant::now();
    let basis = generate_qmc_noci_basis(ao, noci_reference_basis, input);
    let d_basis = t_basis.elapsed();
    let n = basis.len();

    // Save indices in the coefficients vector of the references.
    let ref_indices: Vec<usize> = noci_reference_basis.iter().map(|ref_st| {basis.iter()
                                  .position(|qmc_st| qmc_st.label == ref_st.label).unwrap()}).collect();

    // Embed reference NOCI coefficient vector in full NOCI-QMC space.
    let mut c0qmc = vec![0.0_f64; n]; 
    for (i, ref_st) in noci_reference_basis.iter().enumerate() {
            let idx = basis.iter().position(|qmc_st| qmc_st.label == ref_st.label).unwrap();
            c0qmc[idx] = c0[i];
    }

    if irank == 0 {
        println!("Built NOCI-QMC basis of {} determinants.", n);
        println!("Running stochastic NOCI-QMC propagation....");
    }

    // Choose initial shift.
    let mut es = 0.0;

    // Perform the propagation.
    let t_prop = Instant::now();
    let (e, local_hist) = step(&c0qmc, ao, &basis, &mut es, input, &ref_indices, world);
    let d_prop = t_prop.elapsed();

    // Write excitation histogram to a file. This should currently only be used if doing a single 
    // geometry at a time otherwise the previous file will be overwritten. Writes one file per rank.
    if let Some(hist) = local_hist.as_ref() && input.write.write_excitation_hist {
        if irank == 0 {println!("Writing excitation samples to file...");}
        let filepath = format!("{}/excitationsamples{}", input.write.write_dir, irank);
        let file = File::create(filepath).unwrap();
        let mut writer = BufWriter::new(file);

        writeln!(writer, "{} {} {}", hist.logmin, hist.logmax, hist.nbins).unwrap();
        writeln!(writer, "{} {} {}", hist.ntotal, hist.noverflow_low, hist.noverflow_high).unwrap();

        for &c in &hist.counts {
            writeln!(writer, "{}", c).unwrap();
        }
    }

    let d_total = t_total.elapsed();

    (e, d_total, d_basis, d_prop)
}

/// Print important information for current geometry.
/// # Arguments:
///     `res`: Results, contains the aforementioned important information.
///     `input`: Input, user input specifications.
fn print_report(res: &Results, input: &Input) {
    println!("{}", "=".repeat(100));

    println!("Total PySCF time: {:?}", res.timings.pyscf);
    println!("Total SCF time: {:?}", res.timings.scf);

    println!("Total Reference NOCI time: {:?}", res.timings.noci_ref_total);
    println!(r"  H_1 & H_2: {:?}", res.timings.noci_ref_h);

    if input.det.is_some() {
        println!("Total NOCI-QMC deterministic time: {:?}", res.timings.qmc_det_total);
        println!(r"  Basis generation:  {:?}", res.timings.qmc_det_basis);
        println!(r"  H_1 & H_2: {:?}", res.timings.qmc_det_h);
        println!(r"  Deterministic propagation:  {:?}", res.timings.qmc_det_prop);
    }

    if input.qmc.is_some() {
        println!("Total NOCI-QMC stochastic time: {:?}", res.timings.qmc_stoch_total);
        println!(r"  Basis generation:  {:?}", res.timings.qmc_stoch_basis);
        println!(r"  Stochastic propagation:  {:?}", res.timings.qmc_stoch_prop);
    }

    println!("{}", "=".repeat(100));
    println!("R: {}", res.r);
    for (i, st) in res.states.iter().enumerate() {
        println!("State({}): {},  E: {}", i + 1, st.label, st.e);
    }

    println!("State(NOCI-reference): E: {}, [E - E(RHF)]: {}", res.e_noci_ref, res.e_noci_ref - res.e_rhf);
    if let Some(e_det) = res.e_noci_qmc_det {println!("State(NOCI-qmc-deterministic): E: {}, [E - E(RHF)]: {}", e_det, e_det - res.e_rhf);}
    if res.e_noci_qmc_stoch.is_some() {println!("State(NOCI-qmc-qmc): Blocking analysis must be performed");}
    if let Some(e_fci) = res.e_fci {println!("State(FCI): E: {},  [E - E(RHF)]: {}", e_fci, e_fci - res.e_rhf);}

    println!("{}", "=".repeat(100));
}
