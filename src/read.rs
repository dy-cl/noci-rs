// read.rs
use hdf5::File;
use hdf5::types::VarLenUnicode;
use ndarray::{Array1, Array2, Array4};

use crate::{AoData};

/// Antisymmetrise the ERIs.
/// # Arguments 
fn antisymmetrise(eri_coul: &Array4<f64>) -> Array4<f64> {
    let eri_exch = eri_coul.view().permuted_axes([0, 1, 3, 2]).to_owned();
    //let eri_exch = eri_coul.view().permuted_axes([0, 3, 2, 1]).to_owned();
    eri_coul - &eri_exch
}

/// Read in AO integrals (h, eri, s, dm) and other miscellaneous data (enuc, nao,  nelec, aolabels) 
/// from HDF5 generated by PySCF.
/// # Arguments
///     path: String, path to data file.
pub fn read_integrals(path: &str) -> AoData {
    let f = File::open(path).unwrap();
    let n: usize = f.dataset("nao").unwrap().read_scalar().unwrap();
    let eri_coul: Array4<f64> = f.dataset("eri").unwrap().read().unwrap();
    let eri_asym = antisymmetrise(&eri_coul);
    let s: Array2<f64> = f.dataset("S").unwrap().read().unwrap();
    let h: Array2<f64> = f.dataset("h").unwrap().read().unwrap();
    let enuc: f64 = f.dataset("Enuc").unwrap().read_scalar().unwrap();
    let nelec: Array1<i64> = f.dataset("nelec").unwrap().read().unwrap();
    let dm: Array2<f64> = f.dataset("dm").unwrap().read().unwrap();
    let ds = f.dataset("aolabels").unwrap();
    let arr = ds.read_1d::<VarLenUnicode>().unwrap();       
    let labels: Vec<String> = arr.iter().map(|v| v.to_string()).collect();
    let e_fci: Option<f64> = f.dataset("E_fci").ok().and_then(|ds| ds.read_scalar::<f64>().ok());  

    AoData {s, h, eri_coul, eri_asym, enuc, n, nelec, dm, labels, e_fci}
}
